<!DOCTYPE html><html lang="pt"><head ><meta  charset="UTF-8"/><style>
body {
    font-family: sans-serif;
}

section {
    position: relative;
    padding: 1rem;
    border-bottom: black 1px solid;
}
section > button {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
}

blockquote {
    border-left: lightgray 0.2rem solid;
    padding-left: 1.5rem;
    color: #444;
}

table {
    border-collapse: collapse;
    border-top: gray 1px solid;
    border-left: gray 1px solid;
}

tr {
    border-bottom: gray 1px solid;
}

td {
    border-right: gray 1px solid;
}

thead {
    font-weight: bold;
}

thead > tr:nth-child(1) > td:nth-child(3) {
    text-align: center;
}

td {
    min-width: 3rem;
}

td._1 {
    background-color: lightsalmon;
}

td._2 {
    background-color: lightgreen;
}

td._3 {
    background-color: lightpink;
}
</style><title >Potatov</title></head><body ><h1 >Potatov</h1><p ><a  href="https://github.com/elisauhura/Potatov">Repositório no Github</a> | <a  href="monografia.html">Monografia</a></p><section  id="_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD"><h2 >Proposta</h2><button  onclick="if(document.querySelector('#_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD > div').style.display === 'none') { document.querySelector('#_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD > div').style.display = ''; document.querySelector('#_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD > button').innerHTML='esconder'; } else { document.querySelector('#_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD > div').style.display = 'none'; document.querySelector('#_8CDF7CC5-620C-43A2-85AA-D5DA0FF4EDAD > button').innerHTML='expandir'; }">esconder</button><div  style=""><p >A arquitetura RISC-V é um ISA aberta lançada em 2010 que vem ganhando espaço em aplicações comerciais.</p><p >A proposta deste TCC é o desenvolvimento e verificação de um núcleo RISC-V RV32I que seja pequeno e com suporte as extensões A, C, Zicsr e Zifencei. O núcleo tem como alvo o seu uso em sistemas embarcados que possuam restrições de tamanho físico ou de custo. Será usado como base projetos como o SERV [1] e PicoRV32 [2] que oferecem núcleos pequenos, porém sem o suporte ao conjunto de extensões propostas. O suporte ao conjunto proposto permitirá o uso de instruções compactas (que reduz o tamanho dos programas para RISC-V em torno de 30%) bem como o suporte à execução privilegiada para rodar código de terceiros de forma segura.</p><p >Se espera no fim do trabalho a implementação da CPU em Verilog, síntese da mesma em uma FPGA (Xilinx Artix 7) e um conjunto de softwares que demonstrem o funcionamento do chip além da documentação de todo o projeto.</p><ol ><li ><a  href="https://github.com/olofk/serv">https://github.com/olofk/serv</a></li><li ><a  href="http://github.com/cliffordwolf/picorv32">http://github.com/cliffordwolf/picorv32</a></li></ol></div></section><section  id="_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F"><h2 >Envolvidos</h2><button  onclick="if(document.querySelector('#_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F > div').style.display === 'none') { document.querySelector('#_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F > div').style.display = ''; document.querySelector('#_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F > button').innerHTML='esconder'; } else { document.querySelector('#_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F > div').style.display = 'none'; document.querySelector('#_1C1F77F6-9442-40F1-AE4A-A4A18A004B4F > button').innerHTML='expandir'; }">esconder</button><div  style=""><ul ><li >Nina S. T. Hirata (<a  href="https://www.ime.usp.br/~nina/">website</a>) - Responsável</li><li >Alfredo Goldman (<a  href="https://www.ime.usp.br/~gold/">website</a>) - Supervisor</li><li >Carlos Eduardo de Paula (<a  href="https://twitter.com/carlosedp/">@carlosedp</a>) - Mentor</li><li >Elisa Uhura Pereira da Silva (<a  href="https://twitter.com/elisauhura">@elisauhura</a>) - Aluna</li></ul></div></section><section  id="_BE308313-2BE3-4188-BB16-374E943B8B21"><h2 >Cronograma</h2><button  onclick="if(document.querySelector('#_BE308313-2BE3-4188-BB16-374E943B8B21 > div').style.display === 'none') { document.querySelector('#_BE308313-2BE3-4188-BB16-374E943B8B21 > div').style.display = ''; document.querySelector('#_BE308313-2BE3-4188-BB16-374E943B8B21 > button').innerHTML='esconder'; } else { document.querySelector('#_BE308313-2BE3-4188-BB16-374E943B8B21 > div').style.display = 'none'; document.querySelector('#_BE308313-2BE3-4188-BB16-374E943B8B21 > button').innerHTML='expandir'; }">esconder</button><div  style="overflow-y: scroll;"><table ><thead ><tr ><td rowspan="2">Tarefa</td><td rowspan="2">Status</td><td colspan="13">Mês</td></tr><tr ><td>jan</td><td>fev</td><td>mar</td><td>abr</td><td>mai</td><td>jun</td><td>jul</td><td>ago</td><td>set</td><td>out</td><td>nov</td><td>dez</td></tr></thead><tbody ><tr ><td >Apreender Verilog</td><td >Completa</td><td  class="_1">1</td><td  class="_1">1</td><td  class="_2">2</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td></tr><tr ><td >Adquirir a FPGA</td><td >Completa</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_2">2</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td></tr><tr ><td >Apreender a usar a FPGA</td><td >Completa</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_1">1</td><td  class="_2">2</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td></tr><tr ><td >Estudo da arquitetura RISC-V</td><td >Completa</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_1">1</td><td  class="_1">1</td><td  class="_1">1</td><td  class="_1">1</td><td  class="_2">2</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td></tr><tr ><td >Preparar ambiente para desenvolvimento</td><td >Completa</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_1">1</td><td  class="_1">1</td><td  class="_2">2</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td></tr><tr ><td >Desenvolvimento do núcleo</td><td >Em progresso</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_1">1</td><td  class="_3">3</td><td  class="_0"></td></tr><tr ><td >Validação e síntese do núcleo</td><td >Espera</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_3">3</td><td  class="_0"></td></tr><tr ><td >Organização da documentação</td><td >Em progresso</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_3">3</td><td  class="_0"></td></tr><tr ><td >Escrever monografia</td><td >Em progresso</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_1">1</td><td  class="_1">1</td><td  class="_3">3</td><td  class="_0"></td></tr><tr ><td >Poster do TCC</td><td >Espera</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_3">3</td></tr><tr ><td >Apresentar TCC</td><td >Espera</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_3">3</td></tr><tr ><td >Atualização final</td><td >Espera</td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_0"></td><td  class="_3">3</td></tr></tbody></table><p >Legenda: [1] Em Progresso [2] Concluido [3] Planejado</p></div></section><section  id="_4508BC8C-8507-4EC9-B716-07FF13989FDA"><h2 >Log</h2><button  onclick="if(document.querySelector('#_4508BC8C-8507-4EC9-B716-07FF13989FDA > div').style.display === 'none') { document.querySelector('#_4508BC8C-8507-4EC9-B716-07FF13989FDA > div').style.display = ''; document.querySelector('#_4508BC8C-8507-4EC9-B716-07FF13989FDA > button').innerHTML='esconder'; } else { document.querySelector('#_4508BC8C-8507-4EC9-B716-07FF13989FDA > div').style.display = 'none'; document.querySelector('#_4508BC8C-8507-4EC9-B716-07FF13989FDA > button').innerHTML='expandir'; }">esconder</button><div  style=""><h3 >Minutos trabalhados 19790/28800 (68%)</h3><blockquote ><h4 >2021-04-05 (30min) [pre]</h4><p >Batepapo inicial com o Gold para definir o caminho do TCC. Dentre os pontos importantes da conversa podemos listar:</p><ul ><li >Trabalhar com algo relacionado a RISC-V</li><li >Explorar possíveis projetos já existentes</li></ul></blockquote><blockquote ><h4 >2021-04-06 (300min) [Verilog]</h4><p >Estudo de Verilog com base no livro Verilog HDL do Samir Palnitkar. Parte dos estudos resultaram em um pequeno projeto com exemplos de integração entre Verilog, C e Objective-C. <a  href="https://github.com/elUrso/ObjV">Link para o repositório</a>.</p></blockquote><blockquote ><h4 >2021-04-11 (240min) [pre]</h4><p >Leitura do(s) livro(s) do Patterson e releitura da especificação do RISC-V. Curiosamente, o Patterson já está disponível numa edição que usa o RISC-V.</p></blockquote><blockquote ><h4 >2021-04-27 (240min) [pre]</h4><p >Escrita de um texto sobre os compromissos do RISC-V. <a  href="./compromissos.html">Acesse aqui</a>.</p></blockquote><blockquote ><h4 >2021-05-10 (240min) [pre]</h4><p >Estudo da especificação 0.10 da extensão de vetores do RISC-V,seu contexto em relação a outras extensões (ARM SVE e Intel AVX-512) e escrita de um breve texto sobre a mesma. <a  href="./RVV.html">Acesse aqui</a>.</p></blockquote><blockquote ><h4 >2021-05-14 (60min) [pre]</h4><p >Ingresso do Carlos Eduardo como mentor no projeto.Ele é embaixador RISC-V no Brasil e seu conhecimento técnico no assunto é de grande valor.Realizamos uma conversa acerca do modelo de FPGA a ser comprado e fechamos na Artix 7 da Xilinx.Realizei a aquisicão da placa XC7A100T Wukong da QMTECH e um JTAG para realizar a programação.O equipamento deve chegar na metade de junho.</p></blockquote><blockquote ><h4 >2021-05-15 (30min) [pre]</h4><p >Desenvolvimento da proposta e definição de objetivos parciais.</p></blockquote><blockquote ><h4 >2021-06-04 (120min) [FPGA]</h4><p >Teste de configuração da FPGA Artix-7. Além da preparação do ambiente (criação de máquina virtual e instalação do Vivado), realizei os experimentos disponibilizados pelo fabricante da placa (<a  href="https://github.com/ChinaQMTECH/XC7A100T-200T_Wukong_Board">repo aqui</a>).</p><p >Obter a placa foi um processo relativemente tranquilo, exceto pelo fato de eu ter enviado um endereço inválido. Com isso, ao chegar no correios da minha cidade, o pacote é devolvido para a china 🤯. Felizmente dei sorte ao conseguir comprar uma segunda JTAG no Mercado Livre (a primeira está voltando pra china) e de recuperar o pacote com a FPGA em si. A lição do dia é: revise o endereço de entrega!</p></blockquote><blockquote ><h4 >2021-06-05 (240min) [FPGA]</h4><p >Finalização da configuração do ambiente de desenvolvimento e estudo das interfaces disponíveis na FPGA.</p></blockquote><blockquote ><h4 >2021-09-01 (300min) [Site]</h4><p >Crianção do repositório do projeto, design do novo layout do site e preparação do sistema de renderização dele.</p><p >O sistema basicamente consiste em um render de JSON para HTML extensível por módulos. Assim os log de trabalho podem ser registrados de um modo que permita gerar estatísticas e gerar uma página.</p></blockquote><blockquote ><h4 >2021-09-02 (300min) [Site]</h4><p >Trabalhei nos módulos necessários para renderizar o website. Isso inclui a renderização de tags, injeção de estilo, criação das seções, injeção de outros arquivos e listas.</p></blockquote><blockquote ><h4 >2021-09-06 (400min) [Site, Core]</h4><p >Desenvolvimento do módulo de cronograma e do módulo de log do site. Preparação de uma folha de estilos básica.</p><p >Design da seção de processamento de inteiros do núcleo.</p></blockquote><blockquote ><h4 >2021-09-07 (480min) [Core]</h4><p >Implementação dos módulos de banco de regitro, ALU e soft RAM incluindo alguns testes.</p></blockquote><blockquote ><h4 >2021-09-08 (90min) [Monografia, Core]</h4><p >Preparação do template da monografia e documentação inical da unidade de controle para a primeira iteração do core .</p></blockquote><blockquote ><h4 >2021-09-12 (180min) [Arquitetura]</h4><p >Releitura da especificação do RISC-V para reforço.</p></blockquote><blockquote ><h4 >2021-09-15 (540min) [Simulador, Core]</h4><p >Trabalhei na interface do simulador. Ele será usado para avaliar o comportamento do hardware de forma visual.</p><p >Como desenvolvo em um Mac estou usando a interface nativa e hoje implementei um visualizador para o estado da RAM:</p><img  src="img/sim_001_ram.png" style="object-fit: contain; max-width: 100%;"/><p >Por fim trabalhei no core para que o módulo de soft RAM funcione a partir do C++ para depois ligar com o vetor em C da UI.</p></blockquote><blockquote ><h4 >2021-09-16 (540min) [Simulador, Core]</h4><p >A interface do simulador ganhou alguns botões, mas apenas Load Program funciona por enquanto.</p><img  src="img/sim_002_ram.png" style="object-fit: contain; max-width: 100%;"/><p >Agora o usuário pode definir o conteúdo da ram a partir de qualquer arquivo. Também é possível editar manualmente os bytes da memória e copiar uma região selecionada.</p><p >Por fim trabalhei na interface C++/C/Obj-C entre a CU1 gerada pelo verilator e a aplicação Cocoa. Aproveitando para explicar um pouco como as coisas estão organizadas:</p><p >Os arquivos verilog ficam dentro da pasta stepV. Para um módulo 'X.v' é possível gerar 'testes unitários' a partir do arquivo 'X.unit.cpp' ou uma biblioteca a partir do arquivo 'X.cpp' e sua interface 'X.h'. Por exemplo, para a biblioteca do 'cu1.v' rodamos `$ make cu1.a` e para o 'teste uniário' do 'integer_alu.v' rodamos `$ make integer_alu.unit`.</p></blockquote><blockquote ><h4 >2021-09-17 (300min) [Simulador, Core]</h4><p >Implementei o código para fazer com que os outros botões da interface passassem a funcionar.</p><p >Alterei um pouco o makefile do stepV para gerar objetos que funcionem no Xcode. Vale notar que ainda é necessário linkar no projeto a biblioteca libc++.</p><p >Adicionei o suporte a observação do clock usando o método poke da API do `cu1`.</p></blockquote><blockquote ><h4 >2021-09-21 (270min) [Core]</h4><p >Trabalhei na implementação parcial do sistema de Fetch-Decode-Execute para suporte ao conjunto base RV32I.</p></blockquote><blockquote ><h4 >2021-09-22 (600min) [Core, Simulador, Bra]</h4><p >Implementei parte das instruções base (branch, alu, jump). Adicionei log do valor de registradores no simulador. Adicionei -i instruções no BRA.</p></blockquote><blockquote ><h4 >2021-09-23 (600min) [Core, Simulador, Bra]</h4><p >Implementei parte das instruções base (load, store). Preparei a toolchain de risc-v para compilar programas em C. Adicionei quase todas as instruções RV32I no BRA.</p></blockquote><blockquote ><h4 >2021-09-24 (660min) [Core, Arquitetura]</h4><p >Resolvi um bug na instrução jal. Avaliei qual será o método inical de interface do sistema e dentre as opções optei por utilizar comunicação UART pela simplicidade. Estudei a parte privilegiada da especificação do RISC-V para implemetar a parte de CSR.</p></blockquote><blockquote ><h4 >2021-09-26 (300min) [Projeto]</h4><p >Reorganizei a estrutura do projeto para trabalhar pelo Xcode. Continuei os estudos de arquitetura privilegiada. Comecei a estruturar versão final de testes.</p></blockquote><blockquote ><h4 >2021-09-27 (300min) [Projeto]</h4><p >Trabalhei no rework da unidade de controle para ter suporte a CSRs.</p></blockquote><blockquote ><h4 >2021-09-28 (300min) [Projeto]</h4><p >Trabalhei no sistema de testes integrado ao Xcode.</p></blockquote><blockquote ><h4 >2021-09-29 (720min) [Core, Projeto]</h4><p >Corrigi um bug no memory_fetch. Avancei o rework do control_unit que agora suport instruções dos opcodes LUI, AIUPC, OP e OP-IMM.</p><p >Agora o workflow ocorre marjoriariamente no Xcode, exceto pela programação em Verilog pois o editor não tem suport a hints nem a coloração da sintaxe.</p><p >Isso foi possível com a adição de tracing aos módulos compilados e a adição da classe UHRTestBench que permite executar a simulação a partir de uma série de transformações e constrains. Considere o snippet a seguir:</p><pre >@8: @{
	@"applyOnRise": @[
		@(UHRControlUnitSignalMI_R), @1,
		@(UHRControlUnitSignalMI_D), @0xdeadbeef
	]
},
@9: @{
	@"checkOnLow": @[
		@(UHRControlUnitSignalINST), @0xdeadbeef,
		@(UHRControlUnitSignalSTATE), @(UHRControlUnitStateExecute)
		]
},
@10: @{
	@"pass": @{}
}</pre><p >A chave indica em qual clock que as regras devem ser aplicadas. As regras disponíveis são applyOnRise e applyOnFall para simular estímulos, checkOnLow e checkOnHigh para aplicar constrains e pass para encerrar a simulação. Se algum constrain falhar, uma falha é emitida para o sistema de testes e a simulação contínua até um pass ou chegar no limite de clocks pré definidos pelo usuário.</p></blockquote><blockquote ><h4 >2021-09-30 (660min) [Core, Projeto]</h4><p >Implentei o resto das instruções que estavam disponíveis na versão anterior do core e comecei a reestruturar o PI Sim para executar programas de teste.</p></blockquote><blockquote ><h4 >2021-10-01 (480min) [Core, Simulador, Projeto]</h4><p >Configurei a CI do Xcode para fazer com que os testes sejam executados a cada commit. Reorganizei a parte gráfica do simulador e sua integração com os módulos de simulação.</p></blockquote><blockquote ><h4 >2021-10-04 (480min) [Monografia]</h4><p >Comecei a escrever a introdução da monografia.</p></blockquote><blockquote ><h4 >2021-10-05 (480min) [Monografia]</h4><p >Continuei o trabalho na monografia, principalmente planejando e organizando seções da introdução e monografia.</p></blockquote><blockquote ><h4 >2021-10-06 (150min) [Projeto]</h4><p >Comecei a preparar o projeto para uma pequena reorganização necessária para mitigar bugs no core.</p></blockquote><blockquote ><h4 >2021-10-07 (960min) [Projeto, Testes]</h4><p >Separei a módule renderização do site para um outro repositório. Reduzindo o <i >cluttlering</i>do código. Aproveitando isso criei um outro repositório para recomeçar o código.</p><p >Nas última semana iterei bastante no modo de simular os módulos e escrever os testes, o que fez com que partes do código usassem interfaces diferentes para a mesma tarefa. Começar do zero e ir puxando as partes necessárias se mostrou uma escolha de valor pois pude integrar testes desde o começo e com integrações para ter um controle do progresso. até o momento reescrevi o TestBench e usando a biblioteca OCMock pude resolver pequenos bugs que seríam difíceis de encontrar durante a o uso da biblioteca.</p><p >Apesar de ter consumido bastante tempo, esse rework me ajudou a estruturar melhor o texto da monografia que deverá ser incluído em um site auxiliar logo mais. Ainda falta reescrever algumas coisas mas entendo que o cronograma não está comprometido. Por fim fica a reflexão de que começar com um martelo ajuda, mas uma hora é melhor usar o pincel.</p></blockquote><blockquote ><h4 >2021-10-08 (270min) [Projeto]</h4><p >Redesenhei a interface de memória para assumir um modelo assíncrono.</p></blockquote><blockquote ><h4 >2021-10-11 (520min) [Core, Monografia]</h4><p >Organizei o sistema para renderizar o site da monografia e finalizei a interface de memória.</p></blockquote><blockquote ><h4 >2021-10-13 (780min) [Core, Memory]</h4><p >Implementei o sistema de dispatch necessário para os módulos que precisam fazer interface direta com objetos.</p><p >Implementei o módulo de memória falsa para simulações e testes.</p><p >Resolvi um pequeno problema na ordem de build dos módulos.</p></blockquote><blockquote ><h4 >2021-10-14 (780min) [Core]</h4><p >Trabalhei na implementação do Core, incluindo ALU e rigistradores. Destaco que após adotar um regime de testes mais rígidos, pude melhorar de forma significativa a qualidade da implementação. Bugs pequenos como a falta de um `break;` ou alteração do valor da variável errada costumam ser pegos durante a execução dos testes.</p><p >Um exemplo foi uma operação de shift aritmético que o correto seria `$signed($signed(a) >>> b[4:0]`, mas inicialmente tinha escrito `a >>> b[4:0]`.</p></blockquote><blockquote ><h4 >2021-10-15 (480min) [Core]</h4><p >Continuei o trabalho no core para processamento de instruções e uma implementação inicial de exceções. Para tal adicionei parte do sistema para gerar binários para execução em testes a partir de arquivos em assembly.</p></blockquote><blockquote ><h4 >2021-10-21 (480min) [Monografia]</h4><p >Pesquisei papers relacionados a FPGA para escrever parte da introdução da monografia. Preparei um segundo computador meu para programar a FPGA devivo a organização do meu espaço de trabalho</p></blockquote><blockquote ><h4 >2021-10-22 (600min) [Core]</h4><p >Trabalhei no design da interface de IO do core e realizei alguns testes no Vivado para programar a FPGA.</p></blockquote><blockquote ><h4 >2021-10-23 (480min) [Core]</h4><p >Continuei o trabalho de design das interfaces do core com base no hardware da FPGA e explorei possíveis interfaces para debug do cores.</p></blockquote><blockquote ><h4 >2021-10-24 (120min) [Monografia]</h4><p >Li papers relacionados a FPGA para escrever parte da introdução da monografia: Architecture of Field-Programmable Gate Arrays por ROSE et al e Three Ages of FPGAs: A Retrospective on the First Thirty Years of FPGA Technology por TRIMBERGER.</p></blockquote><blockquote ><h4 >2021-10-25 (240min) [Projeto]</h4><p >Gastei um tempo recuperando o projeto devido um ploblema ao tentar renomear ele e realizei o upgrade do para o macOS Monterey e não tive problemas. Além disso trabalhei no desenho final da arquitetura que pretendo entregar.</p></blockquote><blockquote ><h4 >2021-10-26 (480min) [Core]</h4><p >Trabalhei no módulo de UART para comnunicação.</p></blockquote><blockquote ><h4 >2021-10-27 (540min) [Core]</h4><p >Continuei o trabalho no módulo de UART para comnunicação.</p></blockquote><blockquote ><h4 >2021-10-28 (780min) [Core]</h4><p >Terminei o trabalho no módulo de UART para comnunicação.</p></blockquote><blockquote ><h4 >2021-10-29 (420min) [Core]</h4><p >Trabalhei na arquitetura de interrupt do core.</p></blockquote><blockquote ><h4 >2021-10-30 (120min) [Core]</h4><p >Trabalhei na parte de fetch da arquitetura do core.</p></blockquote><blockquote ><h4 >2021-10-31 (180min) [Core]</h4><p >Trabalhei na parte de execute da arquitetura do core.</p></blockquote><blockquote ><h4 >2021-11-01 (540min) [Core]</h4><p >Trabalhei na parte de execute e captura de exceção do core. Readicionando as instruções do grupo LUI e AUIPC.</p></blockquote><blockquote ><h4 >2021-11-03 (240min) [Core]</h4><p >Continuei na parte de execute e captura de exceção do core. Readicionando as instruções do grupo OPIMM.</p></blockquote><blockquote ><h4 >2021-11-03 (150min) [Core]</h4><p >Continuei na parte de execute e captura de exceção do core. Readicionando as instruções do grupo OP.</p></blockquote></div></section><p >Check the circuit – Spock</p></body></html>